--4. Una función que reciba el nombre del empleado y su fecha de nacimiento y te
--regrese su RFC 
CREATE OR REPLACE FUNCTION OBT_RFC(text,date) RETURNS TEXT
AS $$ 
	DECLARE
	elems text[];
	rfc text;
	BEGIN
	elems := string_to_array($1, ' '); 
    SELECT CONCAT(substr(elems[1],1,1),substr(elems[2],1,1),substr(elems[3],1,1),
				  CAST(EXTRACT(MONTH FROM $2) AS BIGINT) ,CAST(EXTRACT(DAY FROM $2) AS BIGINT) , SUBSTR(CAST(EXTRACT(YEAR FROM $2) AS TEXT),3,4)) INTO rfc;
	RETURN rfc;
	END;
$$ LANGUAGE 'plpgsql';

--1. Una función que reciba el RFC y nos regrese la edad de los clientes y empleados
--de los viveros.
CREATE OR REPLACE FUNCTION EDADES(TEXT) RETURNS SETOF
INTERVAL AS $$
SELECT EDAD FROM 
((SELECT OBT_RFC(CONCAT(NOMBRES,APELLIDO_PATERNO,APELLIDO_MATERNO),FECHA_NACIMIENTO) RFC, AGE(FECHA_NACIMIENTO) EDAD FROM CLIENTE) 
UNION
(SELECT OBT_RFC(CONCAT(NOMBRES,APELLIDO_PATERNO,APELLIDO_MATERNO),FECHA_NACIMIENTO) RFC, AGE(FECHA_NACIMIENTO) EDAD FROM EMPLEADO)) A WHERE RFC = $1;
$$ LANGUAGE SQL;

--2. Una función que reciba el ID del empleado y nos regrese el número de ventas
--que a realizado.

CREATE OR REPLACE FUNCTION NUMERO_VENTAS(INT) RETURNS BIGINT
AS $$
SELECT TOTAL_VENTAS FROM 
((SELECT ID_EMPLEADO,NOMBRES,APELLIDO_PATERNO,APELLIDO_MATERNO,NOMBRE_VIVERO,COUNT(ID_VENTA) TOTAL_VENTAS
FROM EMPLEADO NATURAL JOIN 
 (SELECT ID_EMPLEADO_COBRAR ID_EMPLEADO,ID_VENTA FROM VENTA_FISICA) A
GROUP BY ID_EMPLEADO)) B WHERE ID_EMPLEADO = $1 $$ LANGUAGE SQL;

-- 3. Una función que reciba el RFC y te regrese el número de días faltantes para el
--cumpleaños del empleado o del cliente
CREATE OR REPLACE FUNCTION DIAS_PARA_CUMPLEANIOS(TEXT) RETURNS SETOF
INTERVAL AS $$
SELECT AGE(TO_DATE(CONCAT(ANIO,'-',MES, '-', DIA), 'YYYY-MM-DD')) CUMPLEANIOS FROM 
((SELECT OBT_RFC(CONCAT(NOMBRES,' ',APELLIDO_PATERNO,' ',APELLIDO_MATERNO),FECHA_NACIMIENTO) RFC, EXTRACT(MONTH FROM FECHA_NACIMIENTO) MES, EXTRACT(DAY FROM FECHA_NACIMIENTO) DIA, EXTRACT(YEAR FROM NOW()) ANIO FROM CLIENTE) 
UNION
(SELECT OBT_RFC(CONCAT(NOMBRES,' ',APELLIDO_PATERNO,' ',APELLIDO_MATERNO),FECHA_NACIMIENTO) RFC, EXTRACT(MONTH FROM FECHA_NACIMIENTO) MES, EXTRACT(DAY FROM FECHA_NACIMIENTO) DIA, EXTRACT(YEAR FROM NOW()) ANIO FROM EMPLEADO)) A 
WHERE RFC = $1;
$$ LANGUAGE SQL;

--Una función que reciba el id del cliente y nos regrese 3 valores; cada una de ellas
--con el total de dinero gastado en compras. Los valores deben ser de la siguiente
--manera: Efectivo, Tarjeta débito y Tarjeta de crédito.

CREATE OR REPLACE FUNCTION REGISTRO_GASTOS(INT) RETURNS TEXT
AS $$ 
	DECLARE
	EFECTIVO MONEY;
	DEBITO MONEY;
	CREDITO MONEY;
	RESULTADO TEXT;
	BEGIN
	SELECT SUM(TOTAL) INTO EFECTIVO FROM VENTA_FISICA NATURAL JOIN FORMA_PAGO_FISICA WHERE NOMBRE_FORMA_PAGO = 'efectivo' AND ID_CLIENTE = $1;
	SELECT SUM(TOTAL) INTO DEBITO FROM VENTA_FISICA NATURAL JOIN FORMA_PAGO_FISICA WHERE NOMBRE_FORMA_PAGO = 'débito' AND ID_CLIENTE = $1;
	SELECT SUM(TOTAL) INTO CREDITO FROM VENTA_FISICA NATURAL JOIN FORMA_PAGO_FISICA WHERE NOMBRE_FORMA_PAGO = 'tarjeta de crédito' AND ID_CLIENTE = $1;
	
    SELECT CONCAT('Efectivo: ',EFECTIVO,' Débito: ',DEBITO,' Crédito: ',CREDITO) INTO RESULTADO;
	RETURN RESULTADO;
	END;
$$ LANGUAGE 'plpgsql';

--Función que se encarga de verificar que una cadena es una sucesion de caracteres validos
CREATE OR REPLACE FUNCTION IS_CADENA(VARCHAR(20))
RETURNS BOOLEAN AS $$
	BEGIN
	IF (SELECT CHAR_LENGTH($1) <=20) THEN
		IF ((SELECT TEXTREGEXEQ($1, '^[a-z|A-Z|Á|É|Í|Ó|Ú|Ü|Ñ|á|é|í|ó|ú|ü|ñ| ]+(\.[a-z|A-Z|Á|É|Í|Ó|Ú|Ü|Ñ|á|é|í|ó|ú|ü|ñ| ]+)?$')) = TRUE) THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	ELSE
		RAISE EXCEPTION 'ERROR: Se genero un error al procesar la cadena -> %', $1
		USING HINT = 'Supero la longitud';
	END IF;
	END;
	$$ LANGUAGE 'plpgsql';

